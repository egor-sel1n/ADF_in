#include  "main.h"

const u8 HamCodeTable[256] =
{
	0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x01,
	0x00, 0xff, 0xff, 0x01, 0xff, 0x01, 0x01, 0x01,
	0x00, 0xff, 0xff, 0x02, 0xff, 0x04, 0x08, 0xff,
	0xff, 0x09, 0x05, 0xff, 0x03, 0xff, 0xff, 0x01,
	0x00, 0xff, 0xff, 0x02, 0xff, 0x0a, 0x06, 0xff,
	0xff, 0x07, 0x0b, 0xff, 0x03, 0xff, 0xff, 0x01,
	0xff, 0x02, 0x02, 0x02, 0x03, 0xff, 0xff, 0x02,
	0x03, 0xff, 0xff, 0x02, 0x03, 0x03, 0x03, 0xff,
	0x00, 0xff, 0xff, 0x0c, 0xff, 0x04, 0x06, 0xff,
	0xff, 0x07, 0x05, 0xff, 0x0d, 0xff, 0xff, 0x01,
	0xff, 0x04, 0x05, 0xff, 0x04, 0x04, 0xff, 0x04,
	0x05, 0xff, 0x05, 0x05, 0xff, 0x04, 0x05, 0xff,
	0xff, 0x07, 0x06, 0xff, 0x06, 0xff, 0x06, 0x06,
	0x07, 0x07, 0xff, 0x07, 0xff, 0x07, 0x06, 0xff,
	0x0e, 0xff, 0xff, 0x02, 0xff, 0x04, 0x06, 0xff,
	0xff, 0x07, 0x05, 0xff, 0x03, 0xff, 0xff, 0x0f,
	0x00, 0xff, 0xff, 0x0c, 0xff, 0x0a, 0x08, 0xff,
	0xff, 0x09, 0x0b, 0xff, 0x0d, 0xff, 0xff, 0x01,
	0xff, 0x09, 0x08, 0xff, 0x08, 0xff, 0x08, 0x08,
	0x09, 0x09, 0xff, 0x09, 0xff, 0x09, 0x08, 0xff,
	0xff, 0x0a, 0x0b, 0xff, 0x0a, 0x0a, 0xff, 0x0a,
	0x0b, 0xff, 0x0b, 0x0b, 0xff, 0x0a, 0x0b, 0xff,
	0x0e, 0xff, 0xff, 0x02, 0xff, 0x0a, 0x08, 0xff,
	0xff, 0x09, 0x0b, 0xff, 0x03, 0xff, 0xff, 0x0f,
	0xff, 0x0c, 0x0c, 0x0c, 0x0d, 0xff, 0xff, 0x0c,
	0x0d, 0xff, 0xff, 0x0c, 0x0d, 0x0d, 0x0d, 0xff,
	0x0e, 0xff, 0xff, 0x0c, 0xff, 0x04, 0x08, 0xff,
	0xff, 0x09, 0x05, 0xff, 0x0d, 0xff, 0xff, 0x0f,
	0x0e, 0xff, 0xff, 0x0c, 0xff, 0x0a, 0x06, 0xff,
	0xff, 0x07, 0x0b, 0xff, 0x0d, 0xff, 0xff, 0x0f,
	0x0e, 0x0e, 0x0e, 0xff, 0x0e, 0xff, 0xff, 0x0f,
	0x0e, 0xff, 0xff, 0x0f, 0xff, 0x0f, 0x0f, 0x0f
} ;

/*------------------------------------------------------------------------------------------------------------------------------------------
| Description    : 查表法解出汉明码
| Input          : 一个汉明码（一个字节）
| Output         : NONE
| Return         : 经查表法解出的原码（半个字节），后续需要拼装
| Remark         : 如果解出的是0xff，是错误的，由上层函数处理，本函数不管，只管查表后送出
| Designer       : xudong@engineer.com  2010-6-18 18:34:42
| log            :
------------------------------------------------------------------------------------------------------------------------------------------*/
u8  hamming_decode( u8 hamming )
{
	//u16 i ;

	return  HamCodeTable[ hamming ] ;
/*
	for( i = 0 ; i < sizeof( HamCodeTable ) ; i++ )
	{
		if( HamCodeTable[i] == hamming )
		{
			return HamCodeTable[i] ;
		}
	}

	return 0xff ;
*/
}


/*------------------------------------------------------------------------------------------------------------------------------------------
| Description    : 用于左移任意长度的8bits数组（是按位左移）
| Input          : 指针、数组长度
| Output         : 直接移动既定的数组
| Return         : NONE
| Remark         : 1、只能直接移动u8型数组，其它数组需要改进
                   2、此函数只左移一次
                   3、此函数为循环左移，如果不需要，则最低位应忽略
                   4、入参length是指u8型的长度
                   5、确保编译器及CPU等左移填零
| Designer       : xudong@engineer.com  2010-6-18 16:35:20
| log            : 2010-6-18 17:08:32
                   连续调用此函数8次，验证正确，因为这时各数组元素完成了一次整体左移；
------------------------------------------------------------------------------------------------------------------------------------------*/
void  array_shift_left( u8 *p, u16 length)
{
	u16 i ;
	u8  temp = *p ;  // 定义临时变量用于保存 *p 的最高位，结束后补到数组的最低位上

	for( i = 0 ; i < ( length - 1 ); i++ )
	{
		*p = ( *p << 1 ) | ( *(p + 1) >> 7 ) ;
		p++ ;
	}

	*p <<= 1 ;  // 这是移动最后一个字节

	*p = *p | ( temp >> 7 ) ;  // 数组的最高位补到数组最后一个元素的最低位上
}


/*------------------------------------------------------------------------------------------------------------------------------------------
| Description    : 用于左移任意长度的8bits数组
| Input          : 指针、数组长度
| Output         : 直接移动既定的数组
| Return         : NONE
| Remark         : 1、只能直接移动u8型数组，其它数组需要改进，比如应先转换成u8型数组
                   2、此函数只左移一次
                   3、入参length是指u8型的长度，而比如u16型的则是2倍长度了
| Designer       : xudong@engineer.com  cnchip@163.com   2011-2-25 14:24:21
| log            : 2011-2-25 14:24:27
                   
------------------------------------------------------------------------------------------------------------------------------------------*/
void  ArrayLeftMove1Byte( u8 *p, u16 length )
{
	u16 i ;

	for( i = 0 ; i < length - 1 ; i++ ) // 因为数组的最后一个是用来保存新数据的，所以第一个可以丢掉，最后一个空着待收
	{
		*( p + i ) = *( p + 1 + i ) ;
	}
}
